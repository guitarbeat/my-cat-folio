/**
 * @module Results
 * @description Main results component that displays the final rankings of cat names.
 * Shows the tournament results with ratings and provides option to restart.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - if (!voteHistory || !voteHistory.length) (line 82)
 *   - useEffect(() => (line 129)
 *   - setCurrentRankings(processedRankings); (line 132)
 *   - setIsLoading(false); (line 141)
 *   - async (adjustedRankings) => (line 146)
 *   - setIsLoading(true); (line 148)
 *   - setCurrentRankings(updatedRankings); (line 171)
 *   - setIsLoading(false); (line 186)
 *   - setToast((prev) => ( (line 193)
 *   - useEffect(() => (line 196)
 *   - if (toast.show) (line 197)
 *   - return () => clearTimeout(timer); (line 199)
 *   - useEffect(() => (line 203)
 *   - if (header && window.vfx) (line 206)
 *   - if (window.vfx) (line 213)
 *   - if (bracket && window.vfx) (line 220)
 *   - return () => (line 224)
 *   - if (window.vfx) (line 225)
 *   - if (header) (line 226)
 *   - if (bracket) (line 230)
 *   - useEffect(() => (line 238)
 *   - const addVfx = (selector, config) => (line 241)
 *   - if (el && window.vfx) (line 243)
 *   - addVfx(".stat-card", (line 254)
 *   - addVfx(".tournament-bracket", (line 255)
 *   - return () => (line 257)
 *   - if (isLoading) (line 262)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import React, { useState, useEffect, useCallback, memo } from 'react';

import PropTypes from 'prop-types';

import RankingAdjustment from './RankingAdjustment';
import Bracket from '../../shared/components/Bracket/Bracket';
import CalendarButton from '../../shared/components/CalendarButton/CalendarButton';
import StartTournamentButton from '../../shared/components/StartTournamentButton/StartTournamentButton';
import StatsCard from '../../shared/components/StatsCard/StatsCard';
import { Toast } from '@components';
import useToast from '@hooks/useToast';
import styles from './Results.module.css';

function Results({
  ratings,
  onStartNew,
  userName,
  onUpdateRatings,
  currentTournamentNames,
  voteHistory
}) {
  const [currentRankings, setCurrentRankings] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [hiddenNames] = useState(new Set());

  const { toasts, showToast, removeToast } = useToast({
    maxToasts: 1,
    defaultDuration: 3000
  });

  const showToastMessage = useCallback((message, type = 'info') => {
    showToast({
      message,
      type
    });
  }, [showToast]);

  // Convert vote history to bracket matches
  const getBracketMatches = useCallback(() => {
    if (!voteHistory || !voteHistory.length) {
      return [];
    }

    // Filter to only include matches from the current tournament
    const tournamentNameSet = new Set(
      currentTournamentNames?.map((n) => n.name) || []
    );

    const namesCount = currentTournamentNames?.length || 0;
    const matchesPerRound = Math.ceil(Math.max(2, namesCount) / 2);

    return voteHistory
      .filter(
        (vote) =>
          tournamentNameSet.has(vote.match.left.name) &&
          tournamentNameSet.has(vote.match.right.name)
      )
      .map((vote, index) => {
        // Prefer outcome fields if present
        const leftOutcome = vote?.match?.left?.outcome;
        const rightOutcome = vote?.match?.right?.outcome;
        let winner;
        if (leftOutcome || rightOutcome) {
          const leftWin = leftOutcome === 'win';
          const rightWin = rightOutcome === 'win';
          if (leftWin && rightWin)
            winner = 0; // both
          else if (leftWin && !rightWin) winner = -1;
          else if (!leftWin && rightWin) winner = 1;
          else winner = 2; // neither/skip
        } else if (typeof vote.result === 'number') {
          // Handle exact values (-1, 1, 0.5, 0) and fallback thresholds
          if (vote.result === -1) winner = -1;
          else if (vote.result === 1) winner = 1;
          else if (vote.result === 0.5) winner = 0;
          else if (vote.result === 0) winner = 2;
          else if (vote.result < -0.1) winner = -1;
          else if (vote.result > 0.1) winner = 1;
          else if (Math.abs(vote.result) <= 0.1) winner = 0;
          else winner = 2;
        } else {
          winner = 2;
        }

        const matchNumber = vote?.matchNumber ?? index + 1;
        const round = Math.max(
          1,
          Math.ceil(matchNumber / Math.max(1, matchesPerRound))
        );

        return {
          id: matchNumber,
          round,
          name1: vote.match.left.name,
          name2: vote.match.right.name,
          winner
        };
      });
  }, [voteHistory, currentTournamentNames]);

  // Memoized rankings processor
  const processRankings = useCallback(
    (ratingsData) => {
      // Filter to only include names from the current tournament
      const tournamentNameSet = new Set(
        currentTournamentNames?.map((n) => n.name) || []
      );

      return Object.entries(ratingsData || {})
        .filter(([name]) => tournamentNameSet.has(name))
        .map(([name, rating]) => ({
          name,
          rating: Math.round(
            typeof rating === 'number' ? rating : rating?.rating || 1500
          ),
          wins: typeof rating === 'object' ? rating.wins || 0 : 0,
          losses: typeof rating === 'object' ? rating.losses || 0 : 0,
          change: 0
        }))
        .sort((a, b) => b.rating - a.rating);
    },
    [currentTournamentNames]
  );

  useEffect(() => {
    try {
      const processedRankings = processRankings(ratings);
      setCurrentRankings(processedRankings);
    } catch (error) {
      console.error('Error processing rankings:', error);
      showToastMessage('Error processing rankings data', 'error');
    } finally {
      setIsLoading(false);
    }
  }, [ratings, processRankings, showToastMessage]);

  const handleSaveAdjustments = useCallback(
    async (adjustedRankings) => {
      try {
        setIsLoading(true);

        const updatedRankings = adjustedRankings.map((ranking) => {
          const oldRanking = currentRankings.find(
            (r) => r.name === ranking.name
          );
          return {
            ...ranking,
            change: oldRanking ? ranking.rating - oldRanking.rating : 0
          };
        });

        const newRatings = updatedRankings.map(({ name, rating }) => {
          const existingRating = ratings[name];
          return {
            name,
            rating: Math.round(rating),
            wins: existingRating?.wins || 0,
            losses: existingRating?.losses || 0
          };
        });

        await onUpdateRatings(newRatings);
        setCurrentRankings(updatedRankings);

        showToastMessage('Rankings updated successfully!', 'success');
      } catch (error) {
        console.error('Failed to update rankings:', error);
        showToastMessage('Failed to update rankings. Please try again.', 'error');
      } finally {
        setIsLoading(false);
      }
    },
    [currentRankings, ratings, onUpdateRatings, showToastMessage]
  );

  useEffect(() => {
    // Add cool effects to the results header
    const header = document.querySelector('.results-header');
    if (header && window.vfx) {
      window.vfx.add(header, { shader: 'wave', frequency: 2, amplitude: 0.01 });
    }

    // Add glitch effect to stats cards
    const statCards = document.querySelectorAll('.stat-card');
    statCards.forEach((card) => {
      if (window.vfx) {
        window.vfx.add(card, { shader: 'glitch', intensity: 0.2 });
      }
    });

    // Add RGB shift to the tournament bracket
    const bracket = document.querySelector('.tournament-bracket');
    if (bracket && window.vfx) {
      window.vfx.add(bracket, { shader: 'rgbShift', intensity: 0.3 });
    }

    return () => {
      if (window.vfx) {
        if (header) {
          window.vfx.remove(header);
        }
        statCards.forEach((card) => window.vfx.remove(card));
        if (bracket) {
          window.vfx.remove(bracket);
        }
      }
    };
  }, []);

  // Optimize vfx.js usage
  useEffect(() => {
    const vfxElements = [];

    const addVfx = (selector, config) => {
      const el = document.querySelector(selector);
      if (el && window.vfx) {
        window.vfx.add(el, config);
        vfxElements.push(el);
      }
    };

    addVfx('.results-header', {
      shader: 'wave',
      frequency: 2,
      amplitude: 0.01
    });
    addVfx('.stat-card', { shader: 'glitch', intensity: 0.2 });
    addVfx('.tournament-bracket', { shader: 'rgbShift', intensity: 0.3 });

    return () => {
      vfxElements.forEach((el) => window.vfx?.remove(el));
    };
  }, []);

  if (isLoading) {
    return (
      <div
        className={styles.loading}
        role="status"
        aria-label="Loading rankings"
      >
        <div className={styles.loadingSpinner} aria-hidden="true" />
        <p>Processing rankings...</p>
      </div>
    );
  }

  const bracketMatches = getBracketMatches();

  return (
    <div className={styles.container}>
      <header className={styles.header}>
        <h2>Name Rankings</h2>
        <p className={styles.welcome}>
          Welcome back, <span className={styles.userName}>{userName}</span>!
          Here are your latest name rankings.
        </p>
      </header>

      <div className={styles.content}>
        <div className={styles.statsGrid}>
          <StatsCard
            title="Total Names"
            value={currentRankings.length}
            emoji="ðŸ“Š"
            variant="primary"
            className={styles.statCard}
            valueClassName={styles.statValue}
          />
        </div>

        <RankingAdjustment
          rankings={currentRankings}
          onSave={handleSaveAdjustments}
          onCancel={onStartNew}
        />

        <div className={styles.actions}>
          <StartTournamentButton
            onClick={onStartNew}
            className={styles.startNewButton}
            ariaLabel="Start new tournament"
          >
            Start New Tournament
          </StartTournamentButton>
          <CalendarButton
            rankings={currentRankings}
            userName={userName}
            hiddenNames={hiddenNames}
          />
          <p className={styles.tip} role="note">
            Starting a new tournament will let you rate more names while keeping
            your current rankings.
          </p>
        </div>

        {bracketMatches.length > 0 && (
          <div className={styles.tournamentBracket}>
            <h3>Tournament Bracket</h3>
            <Bracket matches={bracketMatches} />
          </div>
        )}
      </div>

      <Toast
        variant="container"
        toasts={toasts}
        removeToast={removeToast}
        position="bottom-right"
        maxToasts={1}
      />
    </div>
  );
}

Results.displayName = 'Results';

Results.propTypes = {
  ratings: PropTypes.object.isRequired,
  onStartNew: PropTypes.func.isRequired,
  userName: PropTypes.string.isRequired,
  onUpdateRatings: PropTypes.func.isRequired,
  currentTournamentNames: PropTypes.array,
  voteHistory: PropTypes.array
};

export default memo(Results);
