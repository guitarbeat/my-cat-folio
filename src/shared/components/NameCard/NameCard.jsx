/**
 * @module NameCard
 * @description A reusable card component for displaying name options
 * with consistent styling and behavior across the application.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - useEffect(() => (line 66)
 *   - if (isRippling) (line 67)
 *   - return () => clearTimeout(timer); (line 69)
 *   - useEffect(() => (line 74)
 *   - if (!card || disabled) return; (line 76)
 *   - const handleMouseMove = (e) => (line 78)
 *   - setMousePosition( (line 100)
 *   - if (card) (line 103)
 *   - const handleMouseLeave = () => (line 109)
 *   - setMousePosition( (line 114)
 *   - if (card) (line 117)
 *   - return () => (line 126)
 *   - const handleInteraction = (event) => (line 132)
 *   - if (disabled) (line 133)
 *   - setIsRippling(true); (line 153)
 *   - const getAriaLabel = () => (line 159)
 *   - if (description) (line 161)
 *   - if (isSelected) (line 164)
 *   - if (disabled) (line 167)
 *   - const getSafeId = (text) => (line 174)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';
import PropTypes from 'prop-types';
import styles from './NameCard.module.css';

/**
 * NameCard Component
 * @param {Object} props
 * @param {string} props.name - The name to display in the card
 * @param {string} [props.description] - Optional description text
 * @param {boolean} [props.isSelected] - Whether the card is selected
 * @param {Function} [props.onClick] - Click handler function
 * @param {boolean} [props.disabled=false] - Whether the card is disabled
 * @param {string} [props.shortcutHint] - Keyboard shortcut hint
 * @param {string} [props.className=''] - Additional CSS classes
 * @param {('small'|'medium')} [props.size='medium'] - Card size variant
 * @param {Object} [props.metadata] - Optional metadata to display (rating, popularity, etc.)
 * @param {boolean} [props.isAdmin=false] - Whether to show admin controls
 * @param {boolean} [props.isHidden=false] - Whether the name is hidden
 * @param {Function} [props.onToggleVisibility] - Function to toggle name visibility
 * @param {Function} [props.onDelete] - Function to delete the name
 * @param {Function} [props.onSelectionChange] - Function to handle selection change
 */
function NameCard({
  name,
  description,
  isSelected,
  onClick,
  disabled = false,
  shortcutHint,
  className = '',
  size = 'medium',
  metadata,
  isAdmin = false,
  isHidden = false,
  onToggleVisibility,
  onDelete,
  onSelectionChange,
  image
}) {
  const [rippleStyle, setRippleStyle] = useState({});
  const [isRippling, setIsRippling] = useState(false);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [showTooltip, setShowTooltip] = useState(false);
  const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 });
  const cardRef = useRef(null);
  const imgRef = useRef(null);
  const imgContainerRef = useRef(null);

  // Compute a simple face-aware focal Y using edge density (no external libs)
  const computeFocalY = useCallback((imgEl) => {
    try {
      const naturalW = imgEl.naturalWidth || imgEl.width;
      const naturalH = imgEl.naturalHeight || imgEl.height;
      if (!naturalW || !naturalH) return null;

      // Scale image to small analysis size
      const targetW = 128;
      const scale = targetW / naturalW;
      const w = Math.max(16, Math.min(targetW, naturalW));
      const h = Math.max(16, Math.floor(naturalH * scale));

      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(imgEl, 0, 0, w, h);
      const { data } = ctx.getImageData(0, 0, w, h);

      // Compute simple vertical gradient magnitude per row
      const rowEnergy = new Array(h).fill(0);
      const toGray = (r, g, b) => r * 0.299 + g * 0.587 + b * 0.114;
      const idx = (x, y) => (y * w + x) * 4;
      for (let y = 1; y < h - 1; y++) {
        let sum = 0;
        for (let x = 0; x < w; x++) {
          const i1 = idx(x, y - 1);
          const i2 = idx(x, y + 1);
          const g1 = toGray(data[i1], data[i1 + 1], data[i1 + 2]);
          const g2 = toGray(data[i2], data[i2 + 1], data[i2 + 2]);
          sum += Math.abs(g2 - g1);
        }
        rowEnergy[y] = sum / w;
      }

      // Focus on upper 70% of image; cats' faces tend to be there in these shots
      const start = Math.floor(h * 0.08);
      const end = Math.floor(h * 0.7);
      let bestY = start;
      let bestVal = -Infinity;
      for (let y = start; y < end; y++) {
        // Smooth with small window
        const e =
          (rowEnergy[y - 1] || 0) + rowEnergy[y] + (rowEnergy[y + 1] || 0);
        if (e > bestVal) {
          bestVal = e;
          bestY = y;
        }
      }

      // Convert to percent, clamp reasonable range
      const pct = Math.min(60, Math.max(10, Math.round((bestY / h) * 100)));
      return pct;
    } catch {
      return null;
    }
  }, []);

  const handleImageLoad = useCallback(() => {
    const imgEl = imgRef.current;
    const container = imgContainerRef.current;
    if (!imgEl || !container) return;
    const focal = computeFocalY(imgEl);
    if (focal != null) {
      container.style.setProperty('--image-pos-y', `${focal}%`);
    }
  }, [computeFocalY]);

  useEffect(() => {
    if (isRippling) {
      const timer = setTimeout(() => setIsRippling(false), 600);
      return () => clearTimeout(timer);
    }
  }, [isRippling]);

  // Mouse follow effect for background
  useEffect(() => {
    const card = cardRef.current;
    if (!card || disabled) return;

    const handleMouseMove = (e) => {
      const rect = card.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Calculate mouse position for background effect
      const mouseX = (x / rect.width) * 100;
      const mouseY = (y / rect.height) * 100;

      setMousePosition({ x: mouseX, y: mouseY });

      // Set CSS custom properties for mouse position
      if (card) {
        card.style.setProperty('--mouse-x', `${mouseX}%`);
        card.style.setProperty('--mouse-y', `${mouseY}%`);
      }

      // Show tooltip if metadata is available and has relevant data
      if (metadata && (
        metadata.rating ||
        metadata.wins !== undefined ||
        metadata.losses !== undefined ||
        metadata.popularity ||
        metadata.tournaments ||
        (metadata.categories && metadata.categories.length > 0)
      )) {
        // * Safety check for clientX/clientY
        if (typeof e.clientX === 'number' && typeof e.clientY === 'number') {
          setTooltipPosition({ x: e.clientX, y: e.clientY });
          setShowTooltip(true);
        }
      }
    };

    const handleMouseLeave = () => {
      setMousePosition({ x: 50, y: 50 });
      setShowTooltip(false);

      // Reset CSS custom properties
      if (card) {
        card.style.setProperty('--mouse-x', '50%');
        card.style.setProperty('--mouse-y', '50%');
      }
    };

    card.addEventListener('mousemove', handleMouseMove);
    card.addEventListener('mouseleave', handleMouseLeave);

    return () => {
      card.removeEventListener('mousemove', handleMouseMove);
      card.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, [disabled, metadata]);

  const handleInteraction = (event) => {
    if (disabled) {
      return;
    }

    if (
      event.type === 'click' ||
      (event.type === 'keydown' && (event.key === 'Enter' || event.key === ' '))
    ) {
      event.preventDefault();

      // Create ripple effect
      const rect = event.currentTarget.getBoundingClientRect();
      const x = event.clientX ? event.clientX - rect.left : rect.width / 2;
      const y = event.clientY ? event.clientY - rect.top : rect.height / 2;

      setRippleStyle({
        left: `${x}px`,
        top: `${y}px`
      });

      setIsRippling(true);

      // Handle selection change if this is an admin card
      if (isAdmin && onSelectionChange) {
        onSelectionChange(!isSelected);
      }

      // Call the regular onClick if provided
      onClick?.();
    }
  };

  // Handle admin action clicks (prevent card click when clicking admin buttons)
  const handleAdminAction = (e, action) => {
    e.stopPropagation();
    e.preventDefault();
    action();
  };

  // Enhanced accessibility for button state
  const getAriaLabel = () => {
    let label = name;
    if (description) {
      label += ` - ${description}`;
    }
    if (isSelected) {
      label += ' (selected)';
    }
    if (disabled) {
      label += ' (disabled)';
    }
    if (isHidden) {
      label += ' (hidden)';
    }
    return label;
  };

  // Generate safe ID for aria-describedby
  const getSafeId = (text) => {
    return text.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
  };

  const cardClasses = [
    styles.card,
    styles[size],
    isSelected && styles.selected,
    disabled && styles.disabled,
    isHidden && styles.hidden,
    image && styles.hasImage, // * Add special class for cards with images
    className
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <div className={styles.cardContainer}>
      {/* Main card content */}
      <button
        ref={cardRef}
        className={cardClasses}
        onClick={handleInteraction}
        onKeyDown={handleInteraction}
        disabled={disabled}
        aria-pressed={isSelected}
        aria-label={getAriaLabel()}
        aria-describedby={
          description ? `${getSafeId(name)}-description` : undefined
        }
        aria-labelledby={`${getSafeId(name)}-title`}
        type="button"
      >
        {/* Background mouse follow effect */}
        <div
          className={styles.backgroundEffect}
          style={{
            background: `radial-gradient(circle at ${mousePosition.x}% ${mousePosition.y}%, rgba(var(--primary-rgb), 0.1) 0%, transparent 50%)`,
            opacity: disabled ? 0 : 1
          }}
        />

        {/* Cat image when provided */}
        {image && (
          <div
            className={styles.cardImageContainer}
            ref={imgContainerRef}
            style={{
              ['--bg-image']: `url(${image})`
            }}
          >
            {(() => {
              // If this is a static asset under /images, offer avif/webp sources
              if (String(image).startsWith('/assets/images/')) {
                const base = image.includes('.')
                  ? image.replace(/\.[^.]+$/, '')
                  : image;
                return (
                  <picture>
                    <source type="image/avif" srcSet={`${base}.avif`} />
                    <source type="image/webp" srcSet={`${base}.webp`} />
                    <img
                      ref={imgRef}
                      src={image}
                      alt="Cat picture"
                      className={styles.cardImage}
                      loading="lazy"
                      decoding="async"
                      onLoad={handleImageLoad}
                      onError={(e) => {
                        console.error('Image failed to load:', e.target.src);
                      }}
                    />
                  </picture>
                );
              }
              // Otherwise, render a plain <img> (Supabase URL etc.)
              return (
                <img
                  ref={imgRef}
                  src={image}
                  alt="Cat picture"
                  className={styles.cardImage}
                  loading="lazy"
                  decoding="async"
                  onLoad={handleImageLoad}
                  onError={(e) => {
                    console.error('Image failed to load:', e.target.src);
                  }}
                />
              );
            })()}
          </div>
        )}

        <h3 className={styles.name} id={`${getSafeId(name)}-title`}>
          {name}
        </h3>
        {description && (
          <p
            id={`${getSafeId(name)}-description`}
            className={styles.description}
          >
            {description}
          </p>
        )}

        {/* Enhanced metadata display */}
        {metadata && (
          <div className={styles.metadata}>
            {metadata.rating && (
              <span className={styles.metaItem} title="Average Rating">
                ⭐ {metadata.rating}
              </span>
            )}
            {metadata.popularity && (
              <span className={styles.metaItem} title="Popularity Score">
                🔥 {metadata.popularity}
              </span>
            )}
            {metadata.tournaments && (
              <span className={styles.metaItem} title="Tournament Appearances">
                🏆 {metadata.tournaments}
              </span>
            )}
            {metadata.categories && metadata.categories.length > 0 && (
              <div className={styles.categories}>
                {metadata.categories.slice(0, 2).map((category, index) => (
                  <span key={index} className={styles.categoryTag}>
                    {category}
                  </span>
                ))}
                {metadata.categories.length > 2 && (
                  <span className={styles.categoryMore}>
                    +{metadata.categories.length - 2}
                  </span>
                )}
              </div>
            )}
          </div>
        )}

        {shortcutHint && (
          <span className={styles.shortcutHint} aria-hidden="true">
            {shortcutHint}
          </span>
        )}
        {isSelected && (
          <span className={styles.checkMark} aria-hidden="true">
            ✓
          </span>
        )}
        {isRippling && (
          <span
            className={styles.rippleEffect}
            style={rippleStyle}
            aria-hidden="true"
          />
        )}
      </button>

      {/* Admin actions overlay */}
      {isAdmin && (
        <div className={styles.adminActionsOverlay}>
          <button
            onClick={(e) => handleAdminAction(e, () => onToggleVisibility?.())}
            className={styles.actionButton}
            aria-label={`${isHidden ? 'Show' : 'Hide'} ${name}`}
            title={`${isHidden ? 'Show' : 'Hide'} ${name}`}
          >
            {isHidden ? '🔒' : '🔓'}
          </button>
          {isHidden && onDelete && (
            <button
              onClick={(e) => handleAdminAction(e, () => onDelete?.())}
              className={`${styles.actionButton} ${styles.deleteButton}`}
              aria-label={`Delete ${name}`}
              title={`Delete ${name}`}
            >
              🗑️
            </button>
          )}
        </div>
      )}

      {/* Enhanced tooltip with detailed stats */}
      {showTooltip && metadata && tooltipPosition.x > 0 && tooltipPosition.y > 0 && (
        <div
          className={styles.tooltip}
          style={{
            left: Math.min(tooltipPosition.x + 10, typeof window !== 'undefined' ? window.innerWidth - 320 : tooltipPosition.x + 10),
            top: Math.max(tooltipPosition.y - 10, 10),
            zIndex: 1000
          }}
        >
          <div className={styles.tooltipContent}>
            <div className={styles.tooltipHeader}>
              <h3 className={styles.tooltipName}>{name}</h3>
              {metadata.rank && (
                <span className={styles.tooltipRank}>#{metadata.rank}</span>
              )}
            </div>

            {metadata.description && (
              <p className={styles.tooltipDescription}>{metadata.description}</p>
            )}

            <div className={styles.tooltipStats}>
              {metadata.rating && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Rating</span>
                  <span className={styles.tooltipValue}>{metadata.rating}</span>
                </div>
              )}

              {metadata.wins !== undefined && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Wins</span>
                  <span className={styles.tooltipValue}>{metadata.wins}</span>
                </div>
              )}

              {metadata.losses !== undefined && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Losses</span>
                  <span className={styles.tooltipValue}>{metadata.losses}</span>
                </div>
              )}

              {metadata.totalMatches && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Total Matches</span>
                  <span className={styles.tooltipValue}>{metadata.totalMatches}</span>
                </div>
              )}

              {metadata.winRate && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Win Rate</span>
                  <span className={styles.tooltipValue}>{metadata.winRate}%</span>
                </div>
              )}
            </div>

            {metadata.categories && metadata.categories.length > 0 && (
              <div className={styles.tooltipCategories}>
                <span className={styles.tooltipCategoriesLabel}>Categories:</span>
                <div className={styles.tooltipCategoryTags}>
                  {metadata.categories.map((category, index) => (
                    <span key={index} className={styles.tooltipCategoryTag}>
                      {category}
                    </span>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

NameCard.propTypes = {
  name: PropTypes.string.isRequired,
  description: PropTypes.string,
  isSelected: PropTypes.bool,
  onClick: PropTypes.func,
  disabled: PropTypes.bool,
  shortcutHint: PropTypes.string,
  className: PropTypes.string,
  size: PropTypes.oneOf(['small', 'medium']),
  metadata: PropTypes.shape({
    rating: PropTypes.number,
    popularity: PropTypes.number,
    tournaments: PropTypes.number,
    categories: PropTypes.arrayOf(PropTypes.string),
    wins: PropTypes.number,
    losses: PropTypes.number,
    totalMatches: PropTypes.number,
    winRate: PropTypes.number,
    rank: PropTypes.number,
    description: PropTypes.string
  }),
  isAdmin: PropTypes.bool,
  isHidden: PropTypes.bool,
  onToggleVisibility: PropTypes.func,
  onDelete: PropTypes.func,
  onSelectionChange: PropTypes.func
};

export default NameCard;
