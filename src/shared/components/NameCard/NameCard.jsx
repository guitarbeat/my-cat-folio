/**
 * @module NameCard
 * @description A reusable card component for displaying name options
 * with consistent styling and behavior across the application.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - useEffect(() => (line 66)
 *   - if (isRippling) (line 67)
 *   - return () => clearTimeout(timer); (line 69)
 *   - useEffect(() => (line 74)
 *   - if (!card || disabled) return; (line 76)
 *   - const handleMouseMove = (e) => (line 78)
 *   - setMousePosition( (line 100)
 *   - if (card) (line 103)
 *   - const handleMouseLeave = () => (line 109)
 *   - setMousePosition( (line 114)
 *   - if (card) (line 117)
 *   - return () => (line 126)
 *   - const handleInteraction = (event) => (line 132)
 *   - if (disabled) (line 133)
 *   - setIsRippling(true); (line 153)
 *   - const getAriaLabel = () => (line 159)
 *   - if (description) (line 161)
 *   - if (isSelected) (line 164)
 *   - if (disabled) (line 167)
 *   - const getSafeId = (text) => (line 174)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import React, { useState, useEffect, useRef } from 'react';
import PropTypes from 'prop-types';
import CatImage from '../CatImage';
import styles from './NameCard.module.css';

/**
 * NameCard Component
 * @param {Object} props
 * @param {string} props.name - The name to display in the card
 * @param {string} [props.description] - Optional description text
 * @param {boolean} [props.isSelected] - Whether the card is selected
 * @param {Function} [props.onClick] - Click handler function
 * @param {boolean} [props.disabled=false] - Whether the card is disabled
 * @param {string} [props.shortcutHint] - Keyboard shortcut hint
 * @param {string} [props.className=''] - Additional CSS classes
 * @param {('small'|'medium')} [props.size='medium'] - Card size variant
 * @param {Object} [props.metadata] - Optional metadata to display (rating, popularity, etc.)
 * @param {boolean} [props.isAdmin=false] - Whether to show admin controls
 * @param {boolean} [props.isHidden=false] - Whether the name is hidden
 * @param {Function} [props.onToggleVisibility] - Function to toggle name visibility
 * @param {Function} [props.onDelete] - Function to delete the name
 * @param {Function} [props.onSelectionChange] - Function to handle selection change
 */
function NameCard({
  name,
  description,
  isSelected,
  onClick,
  disabled = false,
  shortcutHint,
  className = '',
  size = 'medium',
  metadata,
  isAdmin = false,
  isHidden = false,
  onToggleVisibility,
  onDelete,
  onSelectionChange,
  image
}) {
  const [rippleStyle, setRippleStyle] = useState({});
  const [isRippling, setIsRippling] = useState(false);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [showTooltip, setShowTooltip] = useState(false);
  const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 });
  const cardRef = useRef(null);
  useEffect(() => {
    if (isRippling) {
      const timer = setTimeout(() => setIsRippling(false), 600);
      return () => clearTimeout(timer);
    }
  }, [isRippling]);

  // Mouse follow effect for background
  useEffect(() => {
    const card = cardRef.current;
    if (!card || disabled) return;

    const handleMouseMove = (e) => {
      const rect = card.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Calculate mouse position for background effect
      const mouseX = (x / rect.width) * 100;
      const mouseY = (y / rect.height) * 100;

      setMousePosition({ x: mouseX, y: mouseY });

      // Set CSS custom properties for mouse position
      if (card) {
        card.style.setProperty('--mouse-x', `${mouseX}%`);
        card.style.setProperty('--mouse-y', `${mouseY}%`);
      }

      // Show tooltip if metadata is available and has relevant data
      if (metadata && (
        metadata.rating ||
        metadata.wins !== undefined ||
        metadata.losses !== undefined ||
        metadata.popularity ||
        metadata.tournaments ||
        (metadata.categories && metadata.categories.length > 0)
      )) {
        // * Safety check for clientX/clientY
        if (typeof e.clientX === 'number' && typeof e.clientY === 'number') {
          setTooltipPosition({ x: e.clientX, y: e.clientY });
          setShowTooltip(true);
        }
      }
    };

    const handleMouseLeave = () => {
      setMousePosition({ x: 50, y: 50 });
      setShowTooltip(false);

      // Reset CSS custom properties
      if (card) {
        card.style.setProperty('--mouse-x', '50%');
        card.style.setProperty('--mouse-y', '50%');
      }
    };

    card.addEventListener('mousemove', handleMouseMove);
    card.addEventListener('mouseleave', handleMouseLeave);

    return () => {
      card.removeEventListener('mousemove', handleMouseMove);
      card.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, [disabled, metadata]);

  const handleInteraction = (event) => {
    if (disabled) {
      return;
    }

    if (
      event.type === 'click' ||
      (event.type === 'keydown' && (event.key === 'Enter' || event.key === ' '))
    ) {
      event.preventDefault();

      // Create ripple effect
      const rect = event.currentTarget.getBoundingClientRect();
      const x = event.clientX ? event.clientX - rect.left : rect.width / 2;
      const y = event.clientY ? event.clientY - rect.top : rect.height / 2;

      setRippleStyle({
        left: `${x}px`,
        top: `${y}px`
      });

      setIsRippling(true);

      // Handle selection change if this is an admin card
      if (isAdmin && onSelectionChange) {
        onSelectionChange(!isSelected);
      }

      // Call the regular onClick if provided
      onClick?.();
    }
  };

  // Handle admin action clicks (prevent card click when clicking admin buttons)
  const handleAdminAction = (e, action) => {
    e.stopPropagation();
    e.preventDefault();
    action();
  };

  // Enhanced accessibility for button state
  const getAriaLabel = () => {
    let label = name;
    if (description) {
      label += ` - ${description}`;
    }
    if (isSelected) {
      label += ' (selected)';
    }
    if (disabled) {
      label += ' (disabled)';
    }
    if (isHidden) {
      label += ' (hidden)';
    }
    return label;
  };

  // Generate safe ID for aria-describedby
  const getSafeId = (text) => {
    return text.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
  };

  const cardClasses = [
    styles.card,
    styles[size],
    isSelected && styles.selected,
    disabled && styles.disabled,
    isHidden && styles.hidden,
    image && styles.hasImage, // * Add special class for cards with images
    className
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <div className={styles.cardContainer}>
      {/* Main card content */}
      <button
        ref={cardRef}
        className={cardClasses}
        onClick={handleInteraction}
        onKeyDown={handleInteraction}
        disabled={disabled}
        aria-pressed={isSelected}
        aria-label={getAriaLabel()}
        aria-describedby={
          description ? `${getSafeId(name)}-description` : undefined
        }
        aria-labelledby={`${getSafeId(name)}-title`}
        type="button"
      >
        {/* Background mouse follow effect */}
        <div
          className={styles.backgroundEffect}
          style={{
            background: `radial-gradient(circle at ${mousePosition.x}% ${mousePosition.y}%, rgba(var(--primary-rgb), 0.1) 0%, transparent 50%)`,
            opacity: disabled ? 0 : 1
          }}
        />

        {/* Cat image when provided */}
        {image && (
          <CatImage
            src={image}
            containerClassName={styles.cardImageContainer}
            imageClassName={styles.cardImage}
          />
        )}

        <h3 className={styles.name} id={`${getSafeId(name)}-title`}>
          {name}
        </h3>
        {description && (
          <p
            id={`${getSafeId(name)}-description`}
            className={styles.description}
          >
            {description}
          </p>
        )}

        {/* Enhanced metadata display */}
        {metadata && (
          <div className={styles.metadata}>
            {metadata.rating && (
              <span className={styles.metaItem} title="Average Rating">
                ‚≠ê {metadata.rating}
              </span>
            )}
            {metadata.popularity && (
              <span className={styles.metaItem} title="Popularity Score">
                üî• {metadata.popularity}
              </span>
            )}
            {metadata.tournaments && (
              <span className={styles.metaItem} title="Tournament Appearances">
                üèÜ {metadata.tournaments}
              </span>
            )}
            {metadata.categories && metadata.categories.length > 0 && (
              <div className={styles.categories}>
                {metadata.categories.slice(0, 2).map((category, index) => (
                  <span key={index} className={styles.categoryTag}>
                    {category}
                  </span>
                ))}
                {metadata.categories.length > 2 && (
                  <span className={styles.categoryMore}>
                    +{metadata.categories.length - 2}
                  </span>
                )}
              </div>
            )}
          </div>
        )}

        {shortcutHint && (
          <span className={styles.shortcutHint} aria-hidden="true">
            {shortcutHint}
          </span>
        )}
        {isSelected && (
          <span className={styles.checkMark} aria-hidden="true">
            ‚úì
          </span>
        )}
        {isRippling && (
          <span
            className={styles.rippleEffect}
            style={rippleStyle}
            aria-hidden="true"
          />
        )}
      </button>

      {/* Admin actions overlay */}
      {isAdmin && (
        <div className={styles.adminActionsOverlay}>
          <button
            onClick={(e) => handleAdminAction(e, () => onToggleVisibility?.())}
            className={styles.actionButton}
            aria-label={`${isHidden ? 'Show' : 'Hide'} ${name}`}
            title={`${isHidden ? 'Show' : 'Hide'} ${name}`}
          >
            {isHidden ? 'üîí' : 'üîì'}
          </button>
          {isHidden && onDelete && (
            <button
              onClick={(e) => handleAdminAction(e, () => onDelete?.())}
              className={`${styles.actionButton} ${styles.deleteButton}`}
              aria-label={`Delete ${name}`}
              title={`Delete ${name}`}
            >
              üóëÔ∏è
            </button>
          )}
        </div>
      )}

      {/* Enhanced tooltip with detailed stats */}
      {showTooltip && metadata && tooltipPosition.x > 0 && tooltipPosition.y > 0 && (
        <div
          className={styles.tooltip}
          style={{
            left: Math.min(tooltipPosition.x + 10, typeof window !== 'undefined' ? window.innerWidth - 320 : tooltipPosition.x + 10),
            top: Math.max(tooltipPosition.y - 10, 10),
            zIndex: 1000
          }}
        >
          <div className={styles.tooltipContent}>
            <div className={styles.tooltipHeader}>
              <h3 className={styles.tooltipName}>{name}</h3>
              {metadata.rank && (
                <span className={styles.tooltipRank}>#{metadata.rank}</span>
              )}
            </div>

            {metadata.description && (
              <p className={styles.tooltipDescription}>{metadata.description}</p>
            )}

            <div className={styles.tooltipStats}>
              {metadata.rating && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Rating</span>
                  <span className={styles.tooltipValue}>{metadata.rating}</span>
                </div>
              )}

              {metadata.wins !== undefined && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Wins</span>
                  <span className={styles.tooltipValue}>{metadata.wins}</span>
                </div>
              )}

              {metadata.losses !== undefined && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Losses</span>
                  <span className={styles.tooltipValue}>{metadata.losses}</span>
                </div>
              )}

              {metadata.totalMatches && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Total Matches</span>
                  <span className={styles.tooltipValue}>{metadata.totalMatches}</span>
                </div>
              )}

              {metadata.winRate && (
                <div className={styles.tooltipStat}>
                  <span className={styles.tooltipLabel}>Win Rate</span>
                  <span className={styles.tooltipValue}>{metadata.winRate}%</span>
                </div>
              )}
            </div>

            {metadata.categories && metadata.categories.length > 0 && (
              <div className={styles.tooltipCategories}>
                <span className={styles.tooltipCategoriesLabel}>Categories:</span>
                <div className={styles.tooltipCategoryTags}>
                  {metadata.categories.map((category, index) => (
                    <span key={index} className={styles.tooltipCategoryTag}>
                      {category}
                    </span>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

NameCard.propTypes = {
  name: PropTypes.string.isRequired,
  description: PropTypes.string,
  isSelected: PropTypes.bool,
  onClick: PropTypes.func,
  disabled: PropTypes.bool,
  shortcutHint: PropTypes.string,
  className: PropTypes.string,
  size: PropTypes.oneOf(['small', 'medium']),
  metadata: PropTypes.shape({
    rating: PropTypes.number,
    popularity: PropTypes.number,
    tournaments: PropTypes.number,
    categories: PropTypes.arrayOf(PropTypes.string),
    wins: PropTypes.number,
    losses: PropTypes.number,
    totalMatches: PropTypes.number,
    winRate: PropTypes.number,
    rank: PropTypes.number,
    description: PropTypes.string
  }),
  isAdmin: PropTypes.bool,
  isHidden: PropTypes.bool,
  onToggleVisibility: PropTypes.func,
  onDelete: PropTypes.func,
  onSelectionChange: PropTypes.func
};

export default NameCard;
