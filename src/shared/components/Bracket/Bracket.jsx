/**
 * @module Bracket
 * @description A React component that displays a tournament bracket visualization.
 * Shows the progression of matches in a merge sort tournament structure.
 * Supports different match outcomes including wins, ties, and skipped matches.
 *
 * @example
 * <Bracket
 *   matches={[
 *     { id: 1, name1: "Whiskers", name2: "Mittens", winner: -1 },
 *     { id: 2, name1: "Luna", name2: "Shadow", winner: 1 }
 *   ]}
 * />
 *
 * @param {Object} props
 * @param {Array} props.matches - Array of match objects containing match details
 * @param {number} props.matches[].id - Unique identifier for the match
 * @param {string} props.matches[].name1 - First name in the match
 * @param {string} props.matches[].name2 - Second name in the match
 * @param {number} props.matches[].winner - Winner indicator (-1: first, 1: second, 0: both, 2: skip)
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - function Match( (line 59)
 *   - if (!match.winner && match.winner !== 0) (line 61)
 *   - if (match.winner === -1) (line 64)
 *   - if (match.winner === 1) (line 67)
 *   - if (match.winner === 0) (line 70)
 *   - if (match.winner === 2) (line 73)
 *   - const getPlayerClass = (isFirst) => (line 79)
 *   - if (!match.winner && match.winner !== 0) (line 80)
 *   - switch (status) (line 83)
 *   - const getResultBadge = (isFirst) => (line 97)
 *   - switch (status) (line 98)
 *   - function Round( (line 156)
 *   - function Bracket( (line 174)
 *   - if (!matches || matches.length === 0) (line 176)
 *   - if (roundIndex >= 0 && roundIndex < totalRounds) (line 187)
 *   - if (!matches || matches.length === 0) (line 198)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import { memo, useMemo } from 'react';
import PropTypes from 'prop-types';
import styles from './Bracket.module.css';

const MatchResult = {
  PENDING: 'pending',
  FIRST_WIN: 'first',
  SECOND_WIN: 'second',
  BOTH_ADVANCE: 'both',
  SKIPPED: 'skip',
  NEITHER: 'neither'
};

function Match({ match, isLastRound }) {
  const status = useMemo(() => {
    if (!match.winner && match.winner !== 0) {
      return MatchResult.PENDING;
    }
    if (match.winner === -1) {
      return MatchResult.FIRST_WIN;
    }
    if (match.winner === 1) {
      return MatchResult.SECOND_WIN;
    }
    if (match.winner === 0) {
      return MatchResult.BOTH_ADVANCE;
    }
    if (match.winner === 2) {
      return MatchResult.NEITHER;
    }
    return MatchResult.SKIPPED;
  }, [match.winner]);

  const getPlayerClass = (isFirst) => {
    if (!match.winner && match.winner !== 0) {
      return styles.player;
    }
    switch (status) {
      case MatchResult.FIRST_WIN:
        return isFirst ? styles.playerWinner : styles.playerLoser;
      case MatchResult.SECOND_WIN:
        return isFirst ? styles.playerLoser : styles.playerWinner;
      case MatchResult.BOTH_ADVANCE:
        return styles.playerBothWin;
      case MatchResult.NEITHER:
        return styles.playerNeither;
      default:
        return styles.player;
    }
  };

  const getResultBadge = (isFirst) => {
    switch (status) {
      case MatchResult.FIRST_WIN:
        return (
          isFirst && (
            <span className={styles.winnerBadge} title="Winner">
              ✓
            </span>
          )
        );
      case MatchResult.SECOND_WIN:
        return (
          !isFirst && (
            <span className={styles.winnerBadge} title="Winner">
              ✓
            </span>
          )
        );
      case MatchResult.BOTH_ADVANCE:
        return (
          <span className={styles.tieBadge} title="Both Liked">
            ♥
          </span>
        );
      case MatchResult.NEITHER:
        return (
          <span className={styles.skipBadge} title="Skipped">
            ⊘
          </span>
        );
      default:
        return null;
    }
  };

  return (
    <div className={styles.match}>
      <div className={styles.matchContent}>
        <div className={getPlayerClass(true)}>
          <span className={styles.playerName}>{match.name1}</span>
          {getResultBadge(true)}
        </div>
        <div className={styles.vsDivider}>vs</div>
        {match.name2 ? (
          <div className={getPlayerClass(false)}>
            <span className={styles.playerName}>{match.name2}</span>
            {getResultBadge(false)}
          </div>
        ) : (
          <div className={styles.playerBye}>
            <span className={styles.byeText}>Bye</span>
          </div>
        )}
      </div>
      {!isLastRound && <div className={styles.matchConnector} />}
    </div>
  );
}

function Round({ matches, roundNumber, isLastRound }) {
  return (
    <div className={styles.round}>
      <div className={styles.roundHeader}>
        <span className={styles.roundTitle}>Round {roundNumber}</span>
        <span className={styles.roundMatches}>
          {matches.length} {matches.length === 1 ? 'match' : 'matches'}
        </span>
      </div>
      <div className={styles.matches}>
        {matches.map((match) => (
          <Match key={match.id} match={match} isLastRound={isLastRound} />
        ))}
      </div>
    </div>
  );
}

function Bracket({ matches }) {
  const tree = useMemo(() => {
    if (!matches || matches.length === 0) {
      return [];
    }

    // If caller provides explicit round numbers, group by them.
    const hasExplicitRounds = matches.some((m) => typeof m.round === 'number');
    if (hasExplicitRounds) {
      const maxRound = Math.max(
        ...matches.map((m) => (typeof m.round === 'number' ? m.round : 1))
      );
      const grouped = Array.from({ length: maxRound }, () => []);
      matches.forEach((m) => {
        const idx = Math.max(1, Number(m.round) || 1) - 1;
        grouped[idx].push(m);
      });
      // Sort within each round by id if present
      grouped.forEach((round) =>
        round.sort((a, b) => (a.id ?? 0) - (b.id ?? 0))
      );
      return grouped;
    }

    // Fallback: heuristic grouping based on match id using log2
    const totalRounds = Math.ceil(Math.log2(matches.length + 1));
    const rounds = Array(totalRounds)
      .fill()
      .map(() => []);

    matches.forEach((match) => {
      const roundIndex = Math.floor(Math.log2(Math.max(1, match.id)));
      if (roundIndex >= 0 && roundIndex < totalRounds) {
        rounds[roundIndex].push(match);
      }
    });

    // Sort matches within each round
    rounds.forEach((round) => round.sort((a, b) => (a.id ?? 0) - (b.id ?? 0)));

    return rounds;
  }, [matches]);

  if (!matches || matches.length === 0) {
    return <div className={styles.emptyState}>No matches to display yet</div>;
  }

  return (
    <div className={styles.container}>
      <div className={styles.bracket}>
        {tree.map((roundMatches, index) => (
          <Round
            key={index}
            matches={roundMatches}
            roundNumber={index + 1}
            isLastRound={index === tree.length - 1}
          />
        ))}
      </div>
    </div>
  );
}

Bracket.displayName = 'Bracket';

Bracket.propTypes = {
  matches: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.number.isRequired,
      name1: PropTypes.string.isRequired,
      name2: PropTypes.string,
      winner: PropTypes.number,
      round: PropTypes.number
    })
  ).isRequired
};

export default memo(Bracket);
