/**
 * @module useBongoCat
 * @description Custom hook for BongoCat component event handling and positioning
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - export function useBongoCat( (line 45)
 *   - if (containerRef && containerRef.current) (line 58)
 *   - if (viewportWidth <= 768) (line 68)
 *   - setContainerTop(optimalTop); (line 73)
 *   - setCatSize(baseSize * scaleFactor * mobileScaleFactor); (line 81)
 *   - setIsVisible(rect.top < viewportHeight); (line 84)
 *   - setContainerZIndex(containerZ); (line 94)
 *   - if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey) (line 100)
 *   - if (now - lastKeyTimeRef.current > 1000) (line 105)
 *   - setIsPawsDown(true); (line 111)
 *   - if (!isPawsDown && onBongo) (line 114)
 *   - onBongo(); (line 115)
 *   - if (keysHeldRef.current.size === 0) (line 126)
 *   - setIsPawsDown(false); (line 127)
 *   - useEffect(() => (line 132)
 *   - if (containerRef && containerRef.current) (line 137)
 *   - updatePosition(); (line 142)
 *   - const handleScroll = () => (line 145)
 *   - requestAnimationFrame(updatePosition); (line 146)
 *   - return () => (line 165)
 *   - if (resizeObserverRef.current) (line 166)
 *   - return () => (line 178)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import { useCallback, useEffect, useRef, useState } from 'react';

/**
 * Custom hook for BongoCat component functionality
 * @param {Object} options - Hook options
 * @param {Object} options.containerRef - Reference to the container element
 * @param {number} options.size - Base size of the cat
 * @param {Function} options.onBongo - Callback when cat is bongoed
 * @returns {Object} Hook state and handlers
 */
export function useBongoCat({ containerRef, size, onBongo }) {
  const [isPawsDown, setIsPawsDown] = useState(false);
  const [containerTop, setContainerTop] = useState(0);
  const [catSize, setCatSize] = useState(size);
  const [isVisible, setIsVisible] = useState(true);
  const [containerZIndex, setContainerZIndex] = useState(0);

  const lastKeyTimeRef = useRef(0);
  const keysHeldRef = useRef(new Set());
  const resizeObserverRef = useRef(null);

  // Calculate position based on container position with debouncing
  const updatePosition = useCallback(() => {
    if (containerRef && containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const viewportWidth = window.innerWidth;
      const containerWidth = rect.width;

      // Position cat slightly down from the top of the container
      let optimalTop = 19;

      // Apply an additional offset for narrow screens to position the cat better
      if (viewportWidth <= 768) {
        const mobileAdjustment = 5;
        optimalTop += mobileAdjustment;
      }

      setContainerTop(optimalTop);

      // Scale cat based on container width with a mobile-specific adjustment
      const baseSize = size;
      const scaleFactor = Math.min(containerWidth / 500, 1);

      // Make the cat slightly smaller on mobile for better proportions
      const mobileScaleFactor = viewportWidth <= 768 ? 0.9 : 1.0;
      setCatSize(baseSize * scaleFactor * mobileScaleFactor);

      // Show/hide based on visibility
      setIsVisible(rect.top < viewportHeight);

      // Get container's z-index for layering
      const containerComputedStyle = window.getComputedStyle(
        containerRef.current
      );
      const containerZ =
        containerComputedStyle.zIndex === 'auto'
          ? 1
          : parseInt(containerComputedStyle.zIndex, 10);
      setContainerZIndex(containerZ);
    }
  }, [containerRef, size]);

  const handleKeyDown = useCallback(
    (e) => {
      if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey) {
        return;
      }

      const now = Date.now();
      if (now - lastKeyTimeRef.current > 1000) {
        lastKeyTimeRef.current = now;
      }

      // Add the key to the set of keys being held down
      keysHeldRef.current.add(e.key);
      setIsPawsDown(true);

      // Only trigger onBongo if it wasn't already paws down
      if (!isPawsDown && onBongo) {
        onBongo();
      }
    },
    [isPawsDown, onBongo]
  );

  const handleKeyUp = useCallback((e) => {
    // Remove the key from the set of keys being held down
    keysHeldRef.current.delete(e.key);

    // If no keys are being held down anymore, set paws up
    if (keysHeldRef.current.size === 0) {
      setIsPawsDown(false);
    }
  }, []);

  // Set up event listeners and observers with performance optimizations
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);

    // Set up ResizeObserver for container positioning
    if (containerRef && containerRef.current) {
      resizeObserverRef.current = new ResizeObserver(updatePosition);
      resizeObserverRef.current.observe(containerRef.current);

      // Initial position calculation with RAF to avoid forced reflow
      requestAnimationFrame(updatePosition);

      // Throttled scroll handler to prevent excessive reflows
      let scrollTimeout;
      const handleScroll = () => {
        if (scrollTimeout) return;
        scrollTimeout = requestAnimationFrame(() => {
          updatePosition();
          scrollTimeout = null;
        });
      };

      // Throttled resize handler
      let resizeTimeout;
      const handleResize = () => {
        if (resizeTimeout) return;
        resizeTimeout = requestAnimationFrame(() => {
          updatePosition();
          resizeTimeout = null;
        });
      };

      // Track container position with throttled events
      window.addEventListener('scroll', handleScroll, { passive: true });
      window.addEventListener('resize', handleResize, { passive: true });

      // Debounced orientation change handler
      let orientationTimeout;
      const handleOrientationChange = () => {
        if (orientationTimeout) return;
        orientationTimeout = setTimeout(() => {
          requestAnimationFrame(updatePosition);
          orientationTimeout = null;
        }, 100);
      };

      window.addEventListener('orientationchange', handleOrientationChange);

      // Throttled MutationObserver to reduce DOM observation overhead
      let mutationTimeout;
      const handleMutation = () => {
        if (mutationTimeout) return;
        mutationTimeout = requestAnimationFrame(() => {
          updatePosition();
          mutationTimeout = null;
        });
      };

      const mutationObserver = new MutationObserver(handleMutation);
      mutationObserver.observe(document.body, {
        childList: true,
        subtree: false, // Only observe direct children to reduce overhead
        attributes: false // Disable attribute observation to reduce reflows
      });

      return () => {
        if (resizeObserverRef.current) {
          resizeObserverRef.current.disconnect();
        }

        window.removeEventListener('scroll', handleScroll);
        window.removeEventListener('resize', handleResize);
        window.removeEventListener('orientationchange', handleOrientationChange);
        mutationObserver.disconnect();

        // Clean up timeouts
        if (scrollTimeout) cancelAnimationFrame(scrollTimeout);
        if (resizeTimeout) cancelAnimationFrame(resizeTimeout);
        if (orientationTimeout) clearTimeout(orientationTimeout);
        if (mutationTimeout) cancelAnimationFrame(mutationTimeout);
      };
    }

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
    };
  }, [handleKeyDown, handleKeyUp, containerRef, updatePosition]);

  return {
    isPawsDown,
    containerTop,
    catSize,
    isVisible,
    containerZIndex,
    updatePosition
  };
}
